defmodule Porphyr.OneHop do
  alias Porphyr.HierarchyNode
  alias Porphyr.HierarchyOperations


  defp calc_all_activated_children(activated_nodes, current_node) do
    try do
      Enum.reduce(activated_nodes, [], fn { ele_id, value }, acc -> 
        case Enum.find(current_node.narrower, fn child -> child == ele_id end) do
          nil -> 
            acc
          _ ->
            [ { ele_id, value } | acc ]
        end
      end)
    rescue
      _ -> []
    end
  end

  defp iterate_broader_nodes([], hierarchy, _activated_nodes), do: hierarchy
  defp iterate_broader_nodes([ current_id | broader_rest ], hierarchy, activated_nodes) do
    current_node = Dict.get(hierarchy, current_id)

    all_activated_children = calc_all_activated_children(activated_nodes, current_node)    
    
    if length(all_activated_children) >= 2 do
      activated_avg = Enum.reduce(all_activated_children, 0, fn { _id, value }, acc -> acc + value end) / length(all_activated_children)
      updated_hierarchy = Dict.update!(hierarchy, current_id, fn hnode -> %HierarchyNode{ hnode | value: hnode.value + activated_avg } end)
      iterate_broader_nodes(broader_rest, updated_hierarchy, activated_nodes)
    else
      iterate_broader_nodes(broader_rest, hierarchy, activated_nodes)
    end    
  end


  @doc """
  
  """
  def one_hop_activation(hierarchy, activated_nodes) do
    Enum.map(activated_nodes, fn { ele_id, _value } -> 
      %HierarchyNode{broader: ancestors} = Dict.get(hierarchy, ele_id)
      ancestors
    end)
    |> List.flatten
    |> Enum.uniq
    |> iterate_broader_nodes(hierarchy, activated_nodes)
  end
  
  def run(concepts, hierarchy) do
    filled_hierarchy = HierarchyOperations.list_to_hierarchy(concepts, hierarchy)
    
    one_hop_activation(filled_hierarchy, concepts)
    |> HierarchyOperations.vectorize_and_normalize
    |> Enum.sort(fn { _, fst }, { _, scd} -> fst > scd end)
  end
  
  def get(scheduler) do
    send scheduler, { :ready, self }
    
    receive do
      { :process, { :file, folder, doc_id }, out_fun, hierarchy } ->      
        File.read!("#{folder}/#{doc_id}")
        |> String.split("\n")
        |> Enum.map(fn lines -> 
          String.split(lines, [",", ", "])
        end)
        |> List.delete_at(-1)
        |> Enum.reduce(HashDict.new, fn [ _syn, ident ], acc ->
          Dict.update(acc, ident, 1, fn val -> val + 1 end)
        end)
        |> run(hierarchy)
        |> out_fun.(doc_id)
        
        get(scheduler)
      { :process, { database, doc_id }, out_fun, hierarchy } ->      
      
        Chips.Get.flat_doc(database, doc_id)
        |> run(hierarchy)
        |> out_fun.(doc_id)
        
        get(scheduler)
      { :shutdown } ->
        exit(:normal)
    end       
  end 

end
